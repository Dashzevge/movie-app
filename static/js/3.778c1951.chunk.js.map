{"version":3,"sources":["compenents/Movie.js","compenents/Movies.js","compenents/SearchFilter.js","compenents/Pagination.js","../../src/useDebouncedCallback.ts","../../src/useDebounce.ts","pages/Home.js"],"names":["Movie","_ref","movie","React","createElement","className","src","posterUrl","NO_IMAGE","alt","title","rating","Link","to","id","Movies","movies","map","key","SearchFilter","_genres$find","genres","selectedGenre","search","onSearchChange","onGenreSelect","type","data-bs-toggle","aria-expanded","find","g","onClick","genre","aria-label","value","onChange","Pagination","currentPage","totalPages","onPageChange","onPageSizeChange","htmlFor","disabled","c","e","u","i","a","r","o","f","l","v","m","d","current","p","window","w","TypeError","s","leading","x","trailing","h","y","debounceOnServer","F","Math","max","maxWait","n","t","apply","cancelAnimationFrame","requestAnimationFrame","setTimeout","Date","now","min","A","slice","call","arguments","cancel","clearTimeout","isPending","flush","Home","dispatch","useDispatch","useSelector","state","pageSize","pagination","searchTerm","debouncedSearchTerm","equalityFn","useDebounce","useEffect","async","response","getAllMovies","API_ENDPOINTS","MOVIES","setMovies","data","setTotalPages","error","console","fetchMovies","getAllGenres","GENRES","setGenres","fetchAllGenres","event","setSearchTerm","target","genreId","setSelectedGenre","page","setPage","setPageSize","Number"],"mappings":"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","file":"static/js/3.778c1951.chunk.js","sourcesContent":["import React from 'react';\nimport { Link } from 'react-router-dom';\nimport { NO_IMAGE } from '../constants';\n\nexport const Movie = ({ movie }) => {\n    return (\n        <div className=\"card\">\n            <img src={movie.posterUrl || NO_IMAGE} className=\"card-img-top\" alt={movie.title} />\n            <div className=\"card-body\">\n                <h5 className=\"card-title\">{movie.title}</h5>\n                <p className=\"card-text\">\n                    <small className=\"text-muted\">Rate: {movie.rating}</small>\n                </p>\n                <Link to={`/movie/${movie.id}`} className=\"btn btn-primary\">Read more</Link>\n            </div>\n        </div>\n    );\n};\n","import React from 'react';\nimport { Movie } from './Movie';\n\n\nexport const Movies = ({ movies }) => {\n    return (\n        <div className=\"container\">\n            <div className=\"row\">\n                {movies.map((movie) => (\n                    <div key={movie.id} className=\"col-md-3 mb-3\">\n                        <Movie movie={movie} />\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n};\n","\nimport React from 'react';\nexport const SearchFilter = ({ genres, selectedGenre, search, onSearchChange, onGenreSelect }) => {\n    return (\n        <div className=\"row justify-content-md-center\">   \n            <div className=\"input-group mb-3\" id=\"buttonGroup\">\n                <button className=\"btn btn-outline-secondary dropdown-toggle\" type=\"button\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n                    {selectedGenre ? genres.find(g => g.title === selectedGenre)?.title : 'All Genres'}\n                </button>\n                <ul className=\"dropdown-menu\">\n                    <li key=\"all\">\n                        <button className=\"dropdown-item\" onClick={() => onGenreSelect('')}>\n                            All Genres\n                        </button>\n                    </li>\n                    {genres.map((genre) => (\n                        <li key={genre.id}>\n                            <button className=\"dropdown-item\" onClick={() => onGenreSelect(genre.title)}>\n                                {genre.title}\n                            </button>\n                        </li>\n                    ))}\n                </ul>\n                <input \n                    type=\"search\" \n                    className=\"form-control\" \n                    aria-label=\"Text input with dropdown button\" \n                    value={search} \n                    onChange={onSearchChange} \n                />\n            </div>\n        </div>\n    );\n};\n","import React from 'react';\n\nexport const Pagination = ({ currentPage, totalPages, onPageChange, onPageSizeChange }) => {\n    return (\n        <div className=\"row md-3\">\n            <div className=\"col d-flex justify-content-between\">\n                <div>\n                    <label htmlFor=\"pageSize\" className=\"form-label\">Page Size:</label>\n                    <select id=\"pageSize\" className=\"form-select\" onChange={onPageSizeChange}>    \n                        <option value={25}>25</option>\n                        <option value={30}>30</option>\n                        <option value={50}>50</option>\n                    </select>\n                </div>\n                <div>\n                    <button\n                        className=\"btn btn-outline-secondary\"\n                        onClick={() => onPageChange(currentPage - 1)}\n                        disabled={currentPage === 1}\n                    >\n                        Previous\n                    </button>\n                    <span className=\"mx-2\">Page {currentPage} of {totalPages}</span>\n                    <button\n                        className=\"btn btn-outline-secondary\"\n                        onClick={() => onPageChange(currentPage + 1)}\n                        disabled={currentPage === totalPages}\n                    >\n                        Next\n                    </button>\n                </div>\n            </div>\n        </div>\n    );\n};\n","import { useRef, useEffect, useMemo } from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n  /**\n   * If the setting is set to true, all debouncing and timers will happen on the server side as well\n   */\n  debounceOnServer?: boolean;\n}\n\nexport interface ControlFunctions<ReturnT> {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => ReturnT | undefined;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function return the result of the last func invocation.\n * Note, that if there are no previous invocations you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>>\n  extends ControlFunctions<ReturnType<T>> {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(func: T, wait?: number, options?: Options): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n  // Always keep the latest version of debounce callback, with no wait time.\n  funcRef.current = func;\n\n  const isClientSide = typeof window !== 'undefined';\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && isClientSide;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const maxing = 'maxWait' in options;\n  const debounceOnServer =\n    'debounceOnServer' in options ? !!options.debounceOnServer : false; // `false` by default\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF\n        ? requestAnimationFrame(pendingFunc)\n        : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      if (!isClientSide && !debounceOnServer) {\n        return;\n      }\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      if (timerId.current) {\n        useRAF\n          ? cancelAnimationFrame(timerId.current)\n          : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current =\n        lastCallTime.current =\n        lastThis.current =\n        timerId.current =\n          null;\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [\n    leading,\n    maxing,\n    wait,\n    maxWait,\n    trailing,\n    useRAF,\n    isClientSide,\n    debounceOnServer,\n  ]);\n\n  return debounced;\n}\n","import { useCallback, useRef, useReducer } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nfunction reducer<T>(_: T, action: T) {\n  return action;\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: {\n    maxWait?: number;\n    leading?: boolean;\n    trailing?: boolean;\n    equalityFn?: (left: T, right: T) => boolean;\n  }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const [state, dispatch] = useReducer(reducer, value);\n  const debounced = useDebouncedCallback(\n    useCallback((value: T) => dispatch(value), [dispatch]),\n    delay,\n    options\n  );\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  if (eq(state as T, value)) {\n    debounced.cancel();\n  }\n\n  return [state as T, debounced];\n}\n","import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { getAllMovies, getAllGenres } from '../services/movieApi';\nimport { Movies } from '../compenents/Movies';\nimport { SearchFilter } from '../compenents/SearchFilter';\nimport { Pagination } from '../compenents/Pagination';\nimport { setMovies } from '../redux/slices/moviesSlice';\nimport { setGenres } from '../redux/slices/genresSlice';\nimport { setPage, setPageSize, setTotalPages } from '../redux/slices/paginationSlice';\nimport { setSearchTerm, setSelectedGenre } from '../redux/slices/searchSlice';\nimport { API_ENDPOINTS } from '../constants';\nimport { useDebounce } from 'use-debounce';\n\nexport const Home = () => {\n    const dispatch = useDispatch();\n    const movies = useSelector((state) => state.movies);\n    const genres = useSelector((state) => state.genres);\n    const { currentPage, pageSize, totalPages } = useSelector((state) => state.pagination);\n    const { searchTerm, selectedGenre } = useSelector((state) => state.search);\n    const [debouncedSearchTerm] = useDebounce(searchTerm, 100); \n\n    useEffect(() => {\n        const fetchMovies = async () => {\n            try {\n                const response = await getAllMovies(API_ENDPOINTS.MOVIES, currentPage, pageSize, debouncedSearchTerm, selectedGenre);\n                dispatch(setMovies(response.data));\n                dispatch(setTotalPages(response.totalPages));\n            } catch (error) {\n                console.error('Failed to getAllmovies', error);\n            }\n        };\n\n        fetchMovies();\n    }, [currentPage, pageSize, debouncedSearchTerm, selectedGenre, dispatch]);\n\n    useEffect(() => {\n        const fetchAllGenres = async () => {\n            try {\n                const response = await getAllGenres(API_ENDPOINTS.GENRES);\n                dispatch(setGenres(response.data));\n            } catch (error) {\n                console.error('Failed to getAllGenres', error);\n            }\n        };\n\n        fetchAllGenres();\n    }, [dispatch]);\n\n    const handleSearchChange = (event) => {\n        dispatch(setSearchTerm(event.target.value));\n    };\n\n    const handleGenreSelect = (genreId) => {\n        dispatch(setSelectedGenre(genreId));\n    };\n\n    const handlePageChange = (page) => {\n        dispatch(setPage(page));\n    };\n\n    const handlePageSizeChange = (event) => {\n        dispatch(setPageSize(Number(event.target.value)));\n    };\n\n    return (\n        <div className=\"container\">\n            <SearchFilter\n                genres={genres}\n                selectedGenre={selectedGenre}\n                search={searchTerm}\n                onSearchChange={handleSearchChange}\n                onGenreSelect={handleGenreSelect}\n            />\n            <Pagination\n                currentPage={currentPage}\n                totalPages={totalPages}\n                onPageChange={handlePageChange}\n                onPageSizeChange={handlePageSizeChange}\n            />\n            <div className=\"row\">\n                <Movies movies={movies} />\n            </div>\n        </div>\n    );\n};\n\nexport default Home;"],"sourceRoot":""}